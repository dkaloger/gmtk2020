using SplineMesh;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

/// <summary>
/// This scripted started off as a copy of Example Growing Root and Rope Builder
/// in SplineMesh and has been modified to keep up with the mechanics of the Vine. 
/// And to not be overwritten by updates to SplineMesh.
/// 
/// Example of component to show the deformation of the mesh on a changing
/// interval and changing spline nodes.
/// 
/// In this example, as the MeshBender is working on spline space, it will update
/// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
/// it will compute the mesh only once on it's next update call.
/// 
/// This component is only for demo purpose and is not intended to be used as-is.
/// </summary>
[ExecuteInEditMode]
[RequireComponent(typeof(Spline))]
public class Vine : MonoBehaviour
{
    private bool _toUpdate = false;
    private GameObject _generatedPhysicsGO;
    private GameObject GeneratedPhysicsGO
    {
        get
        {
            if (_generatedPhysicsGO == null)
            {
                string generatedName = "generated by " + GetType().Name;
                var generatedTranform = transform.Find(generatedName);
                _generatedPhysicsGO = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);
            }
            return _generatedPhysicsGO;
        }
    }

    /// <summary>
    /// This is the child that the rendered mesh is in
    /// </summary>
    private GameObject generatedModelGameObject;
    private Spline spline;
    private float rate = 0;
    private MeshBender meshBender;
    internal List<GameObject> wayPoints = new List<GameObject>();

    [Header("Physics Settings")]
    public bool disablePhysics = true;

    public GameObject segmentPrefab;
    public int segmentCount;
    public float segmentSpacing;
    [Tooltip("Sending Rotations to the Spline can cause pinching in the mesh if you don't limit the rotation properly. Possible physics joint for that?")]
    public bool sendRotation = false;

    [Header("Visual Settings")]
    public Mesh mesh;
    public Material material;
    public Vector3 rotation;
    public Vector3 scale;

    public float startScale = 1;

    public float DurationInSecond;

    protected WeedInteraction _weed;

    public bool reverseAnimation = false;

    [Header("Randomization")]
    public bool randomizeOnStart = false;

    [Range(0, 5)]
    [SerializeField]
    [Tooltip("A 360 random direction is chosen, and this is how far each spline node will move in that direction.")]
    protected float _maxPositionOffset = 0f;

    [Range(0,1)]
    [SerializeField]
    [Tooltip("0 = 0%, 1 = 100$, .5 = 50%")]
    protected float _probabilityOfSegmentSpawningNewVine = .2f;

	// Start is called before the first frame update
	void Start()
    {
        _weed = transform.parent.GetComponentInChildren<WeedInteraction>();

        if (!_weed && !disablePhysics)
            Debug.LogError("No weed interaction found.");

        if(randomizeOnStart)
		{
            if (!spline)
                spline = GetComponent<Spline>();
            
            foreach(SplineNode node in spline.nodes)
			{
                node.Position += UnityEngine.Random.onUnitSphere * _maxPositionOffset;
                node.Direction += UnityEngine.Random.onUnitSphere; //test rand dir
			}
        }
    }

    private void OnEnable()
    {
        spline = GetComponent<Spline>();
        _toUpdate = true;
        rate = 0;
        Init();
    }

    private void OnValidate()
    {
        _toUpdate = true;
        Init();
    }

    // Update is called once per frame
    void Update()
    {
        if(reverseAnimation)
		{
            rate -= Time.deltaTime / DurationInSecond;
        }
        else
		{
            rate += Time.deltaTime / DurationInSecond;
        }
        
        if (rate > 0 && rate < 1)
        {
            Contort();
        }

        if (disablePhysics)
            return;

        if (_toUpdate)
        {
            _toUpdate = false;
            GeneratePhysicsGOs();
            UpdateSpline();
        }
        UpdateNodes();
    }

    /// <summary>
    /// This Changes the Spline to match the position of the rigidbodies.
    /// </summary>
    private void UpdateNodes()
    {
        int i = 0;
        foreach (GameObject wayPoint in wayPoints)
        {
            var node = spline.nodes[i++];
            if (Vector3.Distance(node.Position, transform.InverseTransformPoint(wayPoint.transform.position)) > 0.001f)
            {
                node.Position = transform.InverseTransformPoint(wayPoint.transform.position);
                if (sendRotation)
                    node.Up = wayPoint.transform.up;
            }
        }
    }

    /// <summary>
    /// Do we have to change the shape of the spline?
    /// </summary>
    private void UpdateSpline()
    {
        foreach (var point in wayPoints.ToList())
        {
            if (point == null) wayPoints.Remove(point);
        }

        int nodeCount = wayPoints.Count;
        // adjust the number of nodes in the spline.
        while (spline.nodes.Count < nodeCount)
        {
            spline.AddNode(new SplineNode(Vector3.zero, Vector3.zero));
        }

        while (spline.nodes.Count > nodeCount && spline.nodes.Count > 2)
        {
            spline.RemoveNode(spline.nodes.Last());
        }
    }

    //came from spline asset
    private void Contort()
    {
        float nodeDistance = 0;
        int i = 0;
        foreach (var n in spline.nodes)
        {
            float nodeDistanceRate = nodeDistance / spline.Length;
            float nodeScale = startScale * (rate - nodeDistanceRate);
            n.Scale = new Vector2(nodeScale, nodeScale);
            if (i < spline.curves.Count)
            {
                nodeDistance += spline.curves[i++].Length;
            }
        }

        if (generatedModelGameObject != null)
        {
            meshBender.SetInterval(spline, 0, spline.Length * rate);
            meshBender.ComputeIfNeeded();
        }
    }

    private void Init()
    {
        //Block of code came from Spline asset
        string generatedName = "generated by " + GetType().Name;
        var generatedTranform = transform.Find(generatedName);
        generatedModelGameObject = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
            typeof(MeshFilter),
            typeof(MeshRenderer),
            typeof(MeshBender));

        generatedModelGameObject.GetComponent<MeshRenderer>().material = material;
        //generatedModelGameObject.tag = "Vine";

        meshBender = generatedModelGameObject.GetComponent<MeshBender>();
        spline = GetComponent<Spline>();

        meshBender.Source = SourceMesh.Build(mesh)
            .Rotate(Quaternion.Euler(rotation))
            .Scale(scale);
        meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
        meshBender.SetInterval(spline, 0, 0.01f);
    }

    private void GeneratePhysicsGOs()
    {
        UOUtility.DestroyChildren(GeneratedPhysicsGO);
        wayPoints.Clear();

        float localSpacing = 0;
        Joint joint = null;
        for (int i = 0; i < segmentCount; i++)
        {
            GameObject seg = UOUtility.Instantiate(segmentPrefab, GeneratedPhysicsGO.transform);
            seg.transform.Translate(0, 0, localSpacing);
            seg.tag = "Vine";

            Rigidbody segRB = seg.GetComponent<Rigidbody>();
            // we fix the first segment so that the vine won't fall
            if (i == 0)
            {
                segRB.constraints = RigidbodyConstraints.FreezePosition;
                seg.GetComponent<Collider>().enabled = false; //disable the collider on the first/center of the plant.

                _weed.vinesToPickBeforeDestorying.Enqueue(seg.transform); //store the first physics segment so the player can grab it with IK
            }
            else if (i == Mathf.Ceil(segmentCount/2))
			{
                //spawn object
                GameObject plantBlock = new GameObject("Generated Plant Block Collider")
                {
                    layer = 11
				};
				plantBlock.transform.position = seg.transform.position;
                plantBlock.transform.SetParent(seg.transform);
                SphereCollider plantBlockCollider = plantBlock.AddComponent<SphereCollider>();
                plantBlockCollider.radius = i * segmentSpacing;
            }

            // we attach the rigidbody to the joint of the previous segment
            if (joint != null)
            {
                joint.connectedBody = segRB;
            }
            joint = seg.GetComponent<Joint>();

            // we save segments as way points for the spline deformation.
            wayPoints.Add(seg);
            localSpacing += segmentSpacing;
        }
        UOUtility.Destroy(joint);
    }
}